% -*- root: main.tex -*-

\chapter{Modelowanie obiektowe dla Cassandry}

Na podstawie wyników wydajnościowych przedstawionych w~sekcji~\ref{sec:cassandra_orm_performance_summary} Autor zaproponował odmienną koncepcję mechanizmu mapowania obiektowego dla bazy danych Cassandra. Aby uwypuklić różnice pomiędzy przedstawioną propozycją i~tradycyjnymi mechanizmami ORM Autor postuluje stosowanie odmiennego nazewnictwa. Omówiona w~sekcji~\ref{sec:om_for_cassandra_concept} koncepcja, która będzie rozwijana w~dalszej części pracy, nazywana będzie \textbf{modelowaniem obiektowym}:

\begin{itemize}
	\item Mechanizmy mapowania obiektowo-relacyjnego nie wymuszają na użytkowniku kolejności projektowania komponentów. Osiągalne są zarówno podejście \emph{code first}\footnote{Code first (ang. dosłownie ,,najpierw kod źródłowy'') - w~kontekście ORM oznacza to modelowanie dziedziny za pomocą kodu źródłowego, z~którego następnie generowany jest schemat bazy danych.}, jak i~\emph{database first}\footnote{Database first (ang. dosłownie ,,najpierw baza danych'') - w~kontekście ORM oznacza to modelowanie dziedziny jako schemat bazodanowy, do którego następnie pisany jest mapujący kod źródłowy.}. W~proponowanym przez Autora modelowaniu obiektowym, ze względu na występowanie struktur wysokiego poziomu odpowiadających wzorcom projektowym, podejście \emph{database first} jest możliwe tylko teoretycznie lub w~bardzo ograniczonym zakresie. Znacznie bardziej efektywne jest podejście \emph{code first}. Posiada ono wsparcie implementacyjne - generację schematu - i~jest rekomendowane przez Autora.
	\item W~mechanizmach mapowania obiektowo-relacyjnego mapowanie odpowiada najczęściej typom danych, natomiast w~obrębie danego typu jest ono jednoznaczne. Przykładowo identyfikator konwertowany jest na liczbowy klucz główny, lista przechowywana jest jako relacja, a~ciąg znaków przekształcany jest na typ \emph{VARCHAR}. W~przypadku modelowania obiektowego dla Cassandry wybór wyznaczać będzie natomiast sposób przechowywania danej wartości. W~zależności od narzuconego sposobu modelowania listy będzie mogła zostać ona zrzutowana na wartość kolumny o~typie \verb+list+, nazwy kolumn w~wierszu lub osobną tabelę.
	\item Mapowanie obiektowo-relacyjne dostarcza przede wszystkim niskopoziomowe odpowiedniki typów bazodanowych. Wyjątkiem jest relacja wiele-do-wielu. Modelowanie obiektowe dla Cassandry skupia się zarówno na polach niskiego poziomu (przykładowo kolumna o~wartości tekstowej), jak i~na reużywalności komponentów wysokopoziomowych odpowiadających wzorcom projektowym.
	\item Częścią modelowania obiektowego dla Cassandry są opcjonalne mechanizmy mapowania obiektowo-relacyjnego. Należą do nich generacja schematu oraz migracje pomiędzy wersjami modelu.
\end{itemize}

W~dalszej części pracy omówiona zostanie konkretna implementacja modelowania obiektowego dostarczona wykonana przez Autora. Pełna nazwa tego projektu to \textbf{Object Modeling for Cassandra}. W~dalszej części pracy używana będzie nazwa skrócona - \emph{OMC}.

\section{OMC - podstawowe pojęcia}

Środowisko aplikacyjne OMC definiuje trzy podstawowe pojęcia: model, pole oraz silnik.

\subsection{Model}

Jest to klasa, która opisuje atomowy względem kodu źródłowego obiekt modelujący bazę danych. Obiekt ten, w~zależności od definicji, może być mapowany na jedną lub wiele tabel. Jedynym wymaganiem, które musi spełnić klasa należąca do modelu jest dziedziczenie po klasie bazowej \verb+Model+. Ciało modelu stanowią pola.

\subsection{Pole}

Pole jest to zmienna klasy definiującej model. Opisuje atomową wartość z~punktu widzenia kodu źródłowego. W~zależności od typu pole może być mapowane na jedną kolumnę, wiele kolumn lub autonomiczną tabelę w~bazie danych. Aby pole klasy mogło zostać zakwalifikowane jako pole modelu, w~definicji klasy należy mu przypisać obiekt dziedziczący po klasie bazowej \verb+Field+.

\subsection{Silnik}

Silnik jest to obiekt, który odpowiada za nawiązywanie połączenia z~bazą danych. Po utworzeniu silnika wystarczy przypisać go do całego modelu. Wszystkie operacje bazodanowe będą domyślnie wykonywane przez przypisany silnik. 

Utworzenie silnika wymaga podania adresu URL opisującego połączenie, nazwanego z~języka angielskiego \emph{connection string}. Strukturę tego adresu przedstawia listing~\ref{lst:connection_string}.

\begin{verbbox}
	cassandra://{ip}:{port}/{keyspace}?rf={rf}&strategy={strategy}
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Struktura adresu URL opisującego połączenie z~bazą danych Cassandra.}
	\label{lst:connection_string}
\end{figure}

Wszystkie elementy ujęte w~znaki \textbf{\{\}} w~adresie~\ref{lst:connection_string} należy zamienić na wartości według poniższego objaśnienia:

\begin{description}
	\item[ip] adres IP węzła koordynatora, z~którym będzie komunikować się kod źródłowy,
	\item[port] port IP koordynatora (podanie portu jest opcjonalne; wartość domyślna to 9042),
	\item[keyspace] przestrzeń nazw Cassandry, w~której operuje OCM,
	\item[rf] współczynnik replikacji\footnote{Współczynnik replikacji (ang. replication factor) - określa na ile węzłów kopiowany jest każdy wstawiony wiersz.} podawany przy tworzeniu przestrzeni nazw, jeżeli ta nie istnieje (parametr jest opcjonalny),
	\item[strategy] nazwa strategii replikacji podawanej przy tworzeniu przestrzeni nazw, jeśli ta nie istnieje (parametr jest opcjonalny).
\end{description}

Do utworzenia silnika służy metoda \verb+Engine.create_engine(connection_string)+. Aby przypisać silnik do modelu należy użyć metody \verb+Model.bind(engine)+. Przykład wywołania przypisującego modelowi silnik dla serwera lokalnego i~przestrzeni nazw \verb+test+ został zaprezentowany na listingu~\ref{lst:engine_creation}.

\begin{verbbox}
	engine = Engine.create_engine('cassandra://127.0.0.1/test')
	Model.bind(engine)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład wywołania tworzącego silnik i~przypisującego go do modelu.}
	\label{lst:engine_creation}
\end{figure} 

\section{Lista życzeń użytkownika - studium przypadku}

Encję użytkownika przy pomocy OMC można opisać modelem \verb+User+ zaprezentowanym na listingu~\ref{lst:omc_user_definition}. Model posiada trzy pola: identyfikator (\verb+id+), imię (\verb+name+) oraz nazwisko (\verb+surname+).

\begin{verbbox}
class User(Model):
    id = UuidField(type=TimeUuid, auto_generate=True, partition_key=True)
    name = TextField(selectable=True)
    surname = TextField(selectable=True)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Tabela użytkownika opisana przy pomocy OMC.}
	\label{lst:omc_user_definition}
\end{figure}

Identyfikator jest opisany polem typu \verb+UuidField+. Ze względu na zadeklarowany parametr \verb+type=TimeUuid+ pole zostanie zmapowane w~Cassandrze jako dana o~typie \verb+timeuuid+. Mechanizm OMC posiada wbudowaną walidację dla identyfikatorów. Przypisanie polu \verb+id+ instancji modelu \verb+User+ błędnej wartości spowoduje zgłoszenie wyjątku \verb+AttributeError+. Parametr \verb+auto_generate=True+ oznacza, że jeżeli identyfikator nie zostanie ustawiony manualnie, to zostanie wygenerowany automatycznie podczas mapowania modelu na bazę danych. Ustawienie \verb+partition_key=True+ oznacza natomiast, że pole będzie częścią klucza wiersza tabeli. 

Imię i~nazwisko opisane są polem typu \verb+TextField+. Jest ono mapowane na bazodanowy typ \verb+text+. Deklaracja \verb+selectable=True+ oznacza, że na polu zostanie utworzony indeks drugiego stopnia. Dzięki temu możliwe jest przeszukiwanie tabeli po wartości tego pola. Na listingu~\ref{lst:user_search_by_name_surname} przedstawiono odwołanie do OCM, dzięki któremu można wyszukać wszystkich użytkowników o~imieniu Jakub i~nazwisko Turek.

\begin{verbbox}
	User.objects().find(name='Jakub', surname='Turek')
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład wyszukiwania użytkownika po imieniu i~nazwisku.}
	\label{lst:user_search_by_name_surname}
\end{figure}

Opis encji przedmiotu w~OMC został zaprezentowany na listingu~\ref{lst:omc_item_definition}. 

\begin{verbbox}
class Item(Model):
    id = UuidField(type=TimeUuid, auto_generate=True, partition_key=True)
    name = TextField(searchable=True, length=255)
    price = DecimalField(total_positions=8, decimal_positions=2)
    desc = TextField()
    category = DictionaryField(entries=['BOOKS', 'CLOTHES', 'FURNITURE'])
    weight = DecimalField(total_positions=5, decimal_positions=1)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Tabela przedmiotu opisana przy pomocy OMC.}
	\label{lst:omc_item_definition}
\end{figure}

W~stosunku do poprzedniej definicji zostały użyte dwa nowe typy pól: \verb+NumberField+ oraz \verb+DictionaryField+. Pierwsze z~nich służy do przechowywania wartości liczb dziesiętnych. Cassandra nie posiada odpowiednika znanego z~relacyjnych baz danych stałoprzecinkowego typu \verb+NUMBER+. O~umieszczanie poprawnie zaokrąglonych wartości musi zadbać autor oprogramowania korzystającego z~Apache Cassandra. Aby to ułatwić, OMC dostarcza programowe wsparcie dla operacji stałoprzecinkowych. Pole \verb+DecimalField+ posiada dwa parametry. Opcja \verb+total_positions+ opisuje maksymalną liczbę cyfr dziesiętnych, z~których może składać się liczba, a~\verb+decimal_positions+ definiuje ile z~tych cyfr należy do części ułamkowej pola. \verb+DecimalField+ w~przezroczysty dla programisty sposób wspiera przypisywanie i~wszystkie operacje arytmetyczne dla typów \verb+int+, \verb+long+ oraz \verb+float+.

Pole \verb+DictionaryField+ dostarcza wsparcia dla słowników jednokrotnego wyboru. Parametr \verb+entries+ pozwala na wyspecyfikowanie listy dozwolonych wartości pola. Podanie wartości spoza listy powoduje zgłoszenie wyjątku \verb+AttributeError+. Typ pola jest automatycznie wnioskowany z~wartości parametru \verb+entries+. Dla listy elementów typu \verb+str+ pole zostanie zmapowanie na wartość typu \verb+text+. W~przypadku, gdy typ nie może być wywnioskowany na podstawie listy, należy podać go jawnie za pomocą parametru \verb+type+.

Opis encji listy życzeń przedstawia listing~\ref{lst:omc_wishlist_definition}.

\begin{verbbox}
class Wishlist(Model):
    userId = UuidField(type=TimeUuid, partition_key=True)
    item = DenormalizedField(relates=Item, 
                             clustering_keys=['itemId'], 
                             fields=['name', 'price'])
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Tabela listy życzeń opisana przy pomocy OMC.}
	\label{lst:omc_wishlist_definition}
\end{figure}

Pole \verb+DenormalizedField+ spełnia postulaty przedstawione w~sekcji~\ref{sec:om_for_cassandra_concept}. Istotny jest fakt, że na podstawie parametru \verb+clustering_keys=['itemId']+ pole \verb+itemId+ staje się częścią złożonego klucza głównego tabeli.

\section{Wsparcie dla wzorców modelowania}

OMC został zaprojektowany w~taki sposób, aby dostarczać mechanizmów wspierających wzorce projektowe. W~tej sekcji Autor opisuje wszystkie wzorce, które były analizowane, modelowane, testowane i~optymalizowane w~trakcie prac implementacyjnych nad OMC.

\subsection{Szereg zdarzeń}

Apache Cassandra została zaprojektowana z~myślą o~wspieraniu szeregów zdarzeń. Szereg zdarzeń to uporządkowane względem czasu wystąpienia wpisy do bazy danych, które opcjonalnie mogą posiadać z~góry określony czas życia. Typowym przykładem szeregu zdarzeń są wartości odczytów z~urządzeń pomiarowych. Wartości te zwyczajowo są pobierane cyklicznie, a~do wykorzystania w~czasie rzeczywistym przydatne są tylko najnowsze odczyty. Doskonały opis modelowania szeregów zdarzeń przedstawiony jest we wpisie Patricka McFadina na portalu \textbf{Planet Cassandra}.~\cite{time_series_modeling_pattern} Artykuł analizuje przykład stacji meteorologicznych. Przedstawia trzy sposoby zapisu szeregu zdarzeń w~Apache Cassandra. 

\paragraph{Odczyty dla tego samego urządzenia w~pojedynczym wierszu} 

Najprostszą możliwością jest zebranie wszystkich próbek dla danego urządzenia w~jednym wierszu tabeli. Kolejne wartości zapisywane są ze śladem czasu w~nazwie kolumny. Listing~\ref{lst:time_series_modeling_one} przedstawia wzorzec zapisany jako model OMC.

\begin{verbbox}
class TimeSeriesPatternOne(Model):
    weatherstation_id = TextField(partitioning_key=True)
    event_time = TimestampField(clustering_key=True, auto_on_create=True)
    temperature = TextField()
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie szeregu zdarzeń. Zapis kolejnych odczytów jako kolumny.}
	\label{lst:time_series_modeling_one}
\end{figure}

Zapis śladu czasu w~nazwie kolumny można uzyskać poprzez dołączenie pola do złożonego klucza głównego tabeli jako \emph{clustering key}\footnote{Clustering key (ang. dosłownie ,,klucz klastrowania'') - część złożonego klucza głównego tabeli, która określa w~jakiej kolejności grupowane są wpisy względem klucza partycjonowania (identyfikatora wiersza).}. Dołączenie to dokonuje się poprzez ustawienie flagi \verb+clustering_key+ na \verb+True+. 

Udogodnieniem dla programisty korzystającego z~OMC jest możliwość automatycznej generacji śladu czasu dla chwili obecnej. Ślad czasu może być wygenerowany w~trakcie tworzenia obiektu (\verb+auto_on_create=True+) lub w~trakcie wstawiania obiektu do bazy danych (\verb+auto_on_save=True+).  

\paragraph{Grupowanie odczytów dla urządzenia i~fragmentu daty} 

W~przypadku gdy odczytów jest zbyt dużo by mieściły się w~jednym wierszu sugerowanym rozwiązaniem jest dodatkowe partycjonowanie wierszy po komponencie daty: miesiącu, dniu, itd. Autor wzorca sugeruje utworzenie w~modelu dodatkowego pola, do którego wpisywany jest komponent daty i~dołączenie tego pola do klucza partycjonowania. Takie modelowanie dziedziny może prowadzić do potencjalnych błędów. Ta sama dana - ślad czasu - przechowywana jest w~dwóch polach, które różnią się formatowaniem. 

OMC posiada mechanizm partycjonowania dat po komponencie. W~modelu znajduje się tylko jedna dana - faktyczny ślad czasu. OMC na jej podstawie automatycznie tworzy i~formatuje klucz partycjonowania. Dzięki temu programista nie musi dbać o~ręczne wyznaczanie komponentu daty. Listing~\ref{lst:time_series_modeling_two} przedstawia opis modelu z~partycjonowaniem względem dnia.

\begin{verbbox}
class TimeSeriesPatternTwo(Model):
    weatherstation_id = TextField(partitioning_key=True)
    event_time = TimestampField(clustering_key=True, 
                                auto_on_create=True, 
                                partitioning_by_day=True)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie szeregu zdarzeń. Partycjonowanie zdarzeń po komponencie daty.}
	\label{lst:time_series_modeling_two}
\end{figure}

Pole \verb+event_time+ modelu \verb+TimeSeriesPatternTwo+ jest kluczem klastrowania. Dodatkowo posiada ono ustawioną flagę \verb+partitioning_by_day=True+, która spełnia trzy zadania:

\begin{itemize}
	\item Przy tworzeniu schematu tabeli dodaje dodatkową kolumnę \verb+event_time_day+\footnote{Nazwa jest tworzona z~nazwy pola oraz nazwy komponentu daty.} o~typie tekstowym. Pole to jest automatycznie włączane do klucza partycjonowania.
	\item Przy zapisywaniu obiektu do bazy danych automatycznie wypełnia wartość dodatkowego pola o~ślad czasu obcięty do z~dokładnością do dnia.
	\item Przy wyszukiwaniu obiektów po dacie automatycznie filtruje dane zarówno po wartości pola \verb+event_time_day+, jak i~\verb+event_time+.
\end{itemize}

Dostępne jest kilka rodzajów komponentów daty, po których można dokonać partycjonowania. Różnią się one ostatnim członem nazwy parametru. Wybór obejmuje partycjonowanie po latach (\verb+_year+), miesiącach (\verb+_month+), dniach (\verb+_day+), godzinach (\verb+_hour+), minutach (\verb+_minute+) oraz sekundach (\verb+_second+).