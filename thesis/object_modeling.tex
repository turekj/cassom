% -*- root: main.tex -*-

\chapter{Modelowanie obiektowe dla Cassandry}

Na podstawie wyników wydajnościowych przedstawionych w~sekcji~\ref{sec:cassandra_orm_performance_summary} Autor zaproponował odmienną koncepcję mechanizmu mapowania obiektowego dla bazy danych Cassandra. Aby uwypuklić różnice pomiędzy przedstawioną propozycją i~tradycyjnymi mechanizmami ORM Autor postuluje stosowanie odmiennego nazewnictwa. Omówiona w~sekcji~\ref{sec:om_for_cassandra_concept} koncepcja, która będzie rozwijana w~dalszej części pracy, nazywana będzie \textbf{modelowaniem obiektowym}:

\begin{itemize}
	\item Mechanizmy mapowania obiektowo-relacyjnego nie wymuszają na użytkowniku kolejności projektowania komponentów. Osiągalne są zarówno podejście \emph{code first}\footnote{Code first (ang. dosłownie ,,najpierw kod źródłowy'') - w~kontekście ORM oznacza to modelowanie dziedziny za pomocą kodu źródłowego, z~którego następnie generowany jest schemat bazy danych.}, jak i~\emph{database first}\footnote{Database first (ang. dosłownie ,,najpierw baza danych'') - w~kontekście ORM oznacza to modelowanie dziedziny jako schemat bazodanowy, do którego następnie pisany jest mapujący kod źródłowy.}. W~proponowanym przez Autora modelowaniu obiektowym, ze względu na występowanie struktur wysokiego poziomu odpowiadających wzorcom projektowym, podejście \emph{database first} jest możliwe tylko teoretycznie lub w~bardzo ograniczonym zakresie. Znacznie bardziej efektywne jest podejście \emph{code first}. Posiada ono wsparcie implementacyjne - generację schematu - i~jest rekomendowane przez Autora.
	\item W~mechanizmach mapowania obiektowo-relacyjnego mapowanie odpowiada najczęściej typom danych, natomiast w~obrębie danego typu jest ono jednoznaczne. Przykładowo identyfikator konwertowany jest na liczbowy klucz główny, lista przechowywana jest jako relacja, a~ciąg znaków przekształcany jest na typ \emph{VARCHAR}. W~przypadku modelowania obiektowego dla Cassandry wybór wyznaczać będzie natomiast sposób przechowywania danej wartości. W~zależności od narzuconego sposobu modelowania listy będzie mogła zostać ona zrzutowana na wartość kolumny o~typie \verb+list+, nazwy kolumn w~wierszu lub osobną tabelę.
	\item Mapowanie obiektowo-relacyjne dostarcza przede wszystkim niskopoziomowe odpowiedniki typów bazodanowych. Wyjątkiem jest relacja wiele-do-wielu. Modelowanie obiektowe dla Cassandry skupia się zarówno na polach niskiego poziomu (przykładowo kolumna o~wartości tekstowej), jak i~na reużywalności komponentów wysokopoziomowych odpowiadających wzorcom projektowym.
	\item Częścią modelowania obiektowego dla Cassandry są opcjonalne mechanizmy mapowania obiektowo-relacyjnego. Należą do nich generacja schematu oraz migracje pomiędzy wersjami modelu.
\end{itemize}

W~dalszej części pracy omówiona zostanie konkretna implementacja modelowania obiektowego dostarczona wykonana przez Autora. Pełna nazwa tego projektu to \textbf{Object Modeling for Cassandra}. W~dalszej części pracy używana będzie nazwa skrócona - \emph{OMC}.

\section{OMC - podstawowe pojęcia}

Środowisko aplikacyjne OMC definiuje trzy podstawowe pojęcia: model, pole oraz silnik.

\subsection{Model}

Jest to klasa, która opisuje atomowy względem kodu źródłowego obiekt modelujący bazę danych. Obiekt ten, w~zależności od definicji, może być mapowany na jedną lub wiele tabel. Jedynym wymaganiem, które musi spełnić klasa należąca do modelu jest dziedziczenie po klasie bazowej \verb+Model+. Ciało modelu stanowią pola.

\subsection{Pole}

Pole jest to zmienna klasy definiującej model. Opisuje atomową wartość z~punktu widzenia kodu źródłowego. W~zależności od typu pole może być mapowane na jedną kolumnę, wiele kolumn lub autonomiczną tabelę w~bazie danych. Aby pole klasy mogło zostać zakwalifikowane jako pole modelu, w~definicji klasy należy mu przypisać obiekt dziedziczący po klasie bazowej \verb+Field+.

\subsection{Silnik}

Silnik jest to obiekt, który odpowiada za nawiązywanie połączenia z~bazą danych. Po utworzeniu silnika wystarczy przypisać go do całego modelu. Wszystkie operacje bazodanowe będą domyślnie wykonywane przez przypisany silnik. 

Utworzenie silnika wymaga podania adresu URL opisującego połączenie, nazwanego z~języka angielskiego \emph{connection string}. Strukturę tego adresu przedstawia listing~\ref{lst:connection_string}.

\begin{verbbox}
	cassandra://{ip}:{port}/{keyspace}?rf={rf}&strategy={strategy}
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Struktura adresu URL opisującego połączenie z~bazą danych Cassandra.}
	\label{lst:connection_string}
\end{figure}

Wszystkie elementy ujęte w~znaki \textbf{\{\}} w~adresie~\ref{lst:connection_string} należy zamienić na wartości według poniższego objaśnienia:

\begin{description}
	\item[ip] adres IP węzła koordynatora, z~którym będzie komunikować się kod źródłowy,
	\item[port] port IP koordynatora (podanie portu jest opcjonalne; wartość domyślna to 9042),
	\item[keyspace] przestrzeń nazw Cassandry, w~której operuje OCM,
	\item[rf] współczynnik replikacji\footnote{Współczynnik replikacji (ang. replication factor) - określa na ile węzłów kopiowany jest każdy wstawiony wiersz.} podawany przy tworzeniu przestrzeni nazw, jeżeli ta nie istnieje (parametr jest opcjonalny),
	\item[strategy] nazwa strategii replikacji podawanej przy tworzeniu przestrzeni nazw, jeśli ta nie istnieje (parametr jest opcjonalny).
\end{description}

Do utworzenia silnika służy metoda \verb+Engine.create_engine(connection_string)+. Aby przypisać silnik do modelu należy użyć metody \verb+Model.bind(engine)+. Przykład wywołania przypisującego modelowi silnik dla serwera lokalnego i~przestrzeni nazw \verb+test+ został zaprezentowany na listingu~\ref{lst:engine_creation}.

\begin{verbbox}
	engine = Engine.create_engine('cassandra://127.0.0.1/test')
	Model.bind(engine)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład wywołania tworzącego silnik i~przypisującego go do modelu.}
	\label{lst:engine_creation}
\end{figure} 

\section{Lista życzeń użytkownika - studium przypadku}

Encję użytkownika przy pomocy OMC można opisać modelem \verb+User+ zaprezentowanym na listingu~\ref{lst:omc_user_definition}. Model posiada trzy pola: identyfikator (\verb+id+), imię (\verb+name+) oraz nazwisko (\verb+surname+).

\begin{verbbox}
class User(Model):
    id = UuidField(type=TimeUuid, auto_generate=True, partition_key=True)
    name = TextField(selectable=True)
    surname = TextField(selectable=True)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Tabela użytkownika opisana przy pomocy OMC.}
	\label{lst:omc_user_definition}
\end{figure}

Identyfikator jest opisany polem typu \verb+UuidField+. Ze względu na zadeklarowany parametr \verb+type=TimeUuid+ pole zostanie zmapowane w~Cassandrze jako dana o~typie \verb+timeuuid+. Mechanizm OMC posiada wbudowaną walidację dla identyfikatorów. Przypisanie polu \verb+id+ instancji modelu \verb+User+ błędnej wartości spowoduje zgłoszenie wyjątku \verb+AttributeError+. Parametr \verb+auto_generate=True+ oznacza, że jeżeli identyfikator nie zostanie ustawiony manualnie, to zostanie wygenerowany automatycznie podczas mapowania modelu na bazę danych. Ustawienie \verb+partition_key=True+ oznacza natomiast, że pole będzie częścią klucza wiersza tabeli. 

Imię i~nazwisko opisane są polem typu \verb+TextField+. Jest ono mapowane na bazodanowy typ \verb+text+. Deklaracja \verb+selectable=True+ oznacza, że na polu zostanie utworzony indeks drugiego stopnia. Dzięki temu możliwe jest przeszukiwanie tabeli po wartości tego pola. Na listingu~\ref{lst:user_search_by_name_surname} przedstawiono odwołanie do OCM, dzięki któremu można wyszukać wszystkich użytkowników o~imieniu Jakub i~nazwisko Turek.

\begin{verbbox}
	User.objects().find(name='Jakub', surname='Turek')
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład wyszukiwania użytkownika po imieniu i~nazwisku.}
	\label{lst:user_search_by_name_surname}
\end{figure}

Opis encji przedmiotu w~OMC został zaprezentowany na listingu~\ref{lst:omc_item_definition}. 

\begin{verbbox}
class Item(Model):
    id = UuidField(type=TimeUuid, auto_generate=True, partition_key=True)
    name = TextField(searchable=True, length=255)
    price = DecimalField(total_positions=8, decimal_positions=2)
    desc = TextField()
    category = DictionaryField(entries=['BOOKS', 'CLOTHES', 'FURNITURE'])
    weight = DecimalField(total_positions=5, decimal_positions=1)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Tabela przedmiotu opisana przy pomocy OMC.}
	\label{lst:omc_item_definition}
\end{figure}

W~stosunku do poprzedniej definicji zostały użyte dwa nowe typy pól: \verb+NumberField+ oraz \verb+DictionaryField+. Pierwsze z~nich służy do przechowywania wartości liczb dziesiętnych. Cassandra nie posiada odpowiednika znanego z~relacyjnych baz danych stałoprzecinkowego typu \verb+NUMBER+. O~umieszczanie poprawnie zaokrąglonych wartości musi zadbać autor oprogramowania korzystającego z~Apache Cassandra. Aby to ułatwić, OMC dostarcza programowe wsparcie dla operacji stałoprzecinkowych. Pole \verb+DecimalField+ posiada dwa parametry. Opcja \verb+total_positions+ opisuje maksymalną liczbę cyfr dziesiętnych, z~których może składać się liczba, a~\verb+decimal_positions+ definiuje ile z~tych cyfr należy do części ułamkowej pola. \verb+DecimalField+ w~przezroczysty dla programisty sposób wspiera przypisywanie i~wszystkie operacje arytmetyczne dla typów \verb+int+, \verb+long+ oraz \verb+float+.

Pole \verb+DictionaryField+ dostarcza wsparcia dla słowników jednokrotnego wyboru. Parametr \verb+entries+ pozwala na wyspecyfikowanie listy dozwolonych wartości pola. Podanie wartości spoza listy powoduje zgłoszenie wyjątku \verb+AttributeError+. Typ pola jest automatycznie wnioskowany z~wartości parametru \verb+entries+. Dla listy elementów typu \verb+str+ pole zostanie zmapowanie na wartość typu \verb+text+. W~przypadku, gdy typ nie może być wywnioskowany na podstawie listy, należy podać go jawnie za pomocą parametru \verb+type+.

Opis encji listy życzeń przedstawia listing~\ref{lst:omc_wishlist_definition}.

\begin{verbbox}
class Wishlist(Model):
    userId = UuidField(type=TimeUuid, partition_key=True)
    item = DenormalizedField(relates=Item, 
                             clustering_keys=['itemId'], 
                             fields=['name', 'price'])
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Tabela listy życzeń opisana przy pomocy OMC.}
	\label{lst:omc_wishlist_definition}
\end{figure}

Pole \verb+DenormalizedField+ spełnia postulaty przedstawione w~sekcji~\ref{sec:om_for_cassandra_concept}. Istotny jest fakt, że na podstawie parametru \verb+clustering_keys=['itemId']+ pole \verb+itemId+ staje się częścią złożonego klucza głównego tabeli.

\section{Wsparcie dla wzorców modelowania}

OMC został zaprojektowany w~taki sposób, aby dostarczać mechanizmów wspierających wzorce projektowe. W~tej sekcji Autor opisuje wszystkie wzorce, które były analizowane, modelowane, testowane i~optymalizowane w~trakcie prac implementacyjnych nad OMC.

\subsection{Szereg zdarzeń}

Apache Cassandra została zaprojektowana z~myślą o~wspieraniu szeregów zdarzeń. Szereg zdarzeń to uporządkowane względem czasu wystąpienia wpisy do bazy danych, które opcjonalnie mogą posiadać z~góry określony czas życia. Typowym przykładem szeregu zdarzeń są wartości odczytów z~urządzeń pomiarowych. Wartości te zwyczajowo są pobierane cyklicznie, a~do wykorzystania w~czasie rzeczywistym przydatne są tylko najnowsze odczyty. Doskonały opis modelowania szeregów zdarzeń przedstawiony jest we wpisie Patricka McFadina na portalu \textbf{Planet Cassandra}.~\cite{time_series_modeling_pattern} Artykuł analizuje przykład stacji meteorologicznych. Przedstawia trzy sposoby zapisu szeregu zdarzeń w~Apache Cassandra. 

\paragraph{Odczyty dla tego samego urządzenia w~pojedynczym wierszu} 

Najprostszą możliwością jest zebranie wszystkich próbek dla danego urządzenia w~jednym wierszu tabeli. Kolejne wartości zapisywane są ze śladem czasu w~nazwie kolumny. Listing~\ref{lst:time_series_modeling_one} przedstawia wzorzec zapisany jako model OMC.

\begin{verbbox}
class TimeSeriesPatternOne(Model):
    weatherstation_id = TextField(partitioning_key=True)
    event_time = TimestampField(clustering_key=True, auto_on_create=True)
    temperature = TextField()
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie szeregu zdarzeń. Zapis kolejnych odczytów jako kolumny.}
	\label{lst:time_series_modeling_one}
\end{figure}

Zapis śladu czasu w~nazwie kolumny można uzyskać poprzez dołączenie pola do złożonego klucza głównego tabeli jako \emph{clustering key}\footnote{Clustering key (ang. dosłownie ,,klucz klastrowania'') - część złożonego klucza głównego tabeli, która określa w~jakiej kolejności grupowane są wpisy względem klucza partycjonowania (identyfikatora wiersza).}. Dołączenie to dokonuje się poprzez ustawienie flagi \verb+clustering_key+ na \verb+True+. 

Udogodnieniem dla programisty korzystającego z~OMC jest możliwość automatycznej generacji śladu czasu dla chwili obecnej. Ślad czasu może być wygenerowany w~trakcie tworzenia obiektu (\verb+auto_on_create=True+) lub w~trakcie wstawiania obiektu do bazy danych (\verb+auto_on_save=True+).  

\paragraph{Grupowanie odczytów dla urządzenia i~fragmentu daty} 

W~przypadku gdy odczytów jest zbyt dużo by mieściły się w~jednym wierszu sugerowanym rozwiązaniem jest dodatkowe partycjonowanie wierszy po komponencie daty: miesiącu, dniu, itd. Autor wzorca sugeruje utworzenie w~modelu dodatkowego pola, do którego wpisywany jest komponent daty i~dołączenie tego pola do klucza partycjonowania. Takie modelowanie dziedziny może prowadzić do potencjalnych błędów. Ta sama dana - ślad czasu - przechowywana jest w~dwóch polach, które różnią się formatowaniem. 

OMC posiada mechanizm partycjonowania dat po komponencie. W~modelu znajduje się tylko jedna dana - faktyczny ślad czasu. OMC na jej podstawie automatycznie tworzy i~formatuje klucz partycjonowania. Dzięki temu programista nie musi dbać o~ręczne wyznaczanie komponentu daty. Listing~\ref{lst:time_series_modeling_two} przedstawia opis modelu z~partycjonowaniem względem dnia.

\begin{verbbox}
class TimeSeriesPatternTwo(Model):
    weatherstation_id = TextField(partitioning_key=True)
    event_time = TimestampField(clustering_key=True, 
                                auto_on_create=True, 
                                partitioning_by_day=True)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie szeregu zdarzeń. Partycjonowanie zdarzeń po komponencie daty.}
	\label{lst:time_series_modeling_two}
\end{figure}

Pole \verb+event_time+ modelu \verb+TimeSeriesPatternTwo+ jest kluczem klastrowania. Dodatkowo posiada ono ustawioną flagę \verb+partitioning_by_day=True+, która spełnia trzy zadania:

\begin{itemize}
	\item Przy tworzeniu schematu tabeli dodaje dodatkową kolumnę \verb+event_time_day+\footnote{Nazwa jest tworzona z~nazwy pola oraz nazwy komponentu daty.} o~typie tekstowym. Pole to jest automatycznie włączane do klucza partycjonowania.
	\item Przy zapisywaniu obiektu do bazy danych automatycznie wypełnia wartość dodatkowego pola o~ślad czasu obcięty do z~dokładnością do dnia.
	\item Przy wyszukiwaniu obiektów po dacie automatycznie filtruje dane zarówno po wartości pola \verb+event_time_day+, jak i~\verb+event_time+.
\end{itemize}

Dostępne jest kilka rodzajów komponentów daty, po których można dokonać partycjonowania. Różnią się one ostatnim członem nazwy parametru. Wybór obejmuje partycjonowanie po latach (\verb+_year+), miesiącach (\verb+_month+), dniach (\verb+_day+), godzinach (\verb+_hour+), minutach (\verb+_minute+) oraz sekundach (\verb+_second+).

\paragraph{Odczyty z~ograniczoną pamięcią}

Korzystając z~wbudowanego mechanizmu Cassandry możliwe jest tworzenie automatycznie przedawniających się wartości. Wstawiając pozycję do bazy danych można ustawić czas życia, po którym zostanie ona usunięta. Przedawnianie się wartości może być wykorzystywane w~połączeniu z~odwrotną kolejnością sortowania wpisów (od najnowszego do najstarszego). Dzięki temu bardzo łatwo jest budować widoki, które prezentują kilka najnowszych informacji.

OMC zapewnia dwa rodzaje wsparcia dla czasu życia wartości. Czas życia może być ustawiany dla indywidualnych obiektów. Przy zapisywaniu obiektu należy na jego instancji wywołać metodę \verb+save(ttl=20)+. Parametr \verb+ttl+ definiuje czas życia wartości w~sekundach. Czas życia można również ustawić globalnie dla wszystkich instancji modelu. Wykorzystuje się do tego pole \verb+__ttl__+ klasy. Zaprezentowano to na listingu~\ref{lst:time_series_modeling_three}.

\begin{verbbox}
class TimeSeriesPatternThree(Model):
    __ttl__ = 20
    weatherstation_id = TextField(partitioning_key=True)
    event_time = TimestampField(clustering_key=True, 
                                descending_clustering=True
                                auto_on_create=True)
    temperature = TextField()
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie szeregu zdarzeń. Przedawniające się odczyty jako kolumny z~sortowaniem od najnowszego.}
	\label{lst:time_series_modeling_three}
\end{figure} 

Dla każdego pola, które jest częścią klucza klastrowania można ustawić odwrotną kolejność sortowania elementów. Do tego celu należy ustawić flagę \verb+descending_clustering+ na \verb+True+.

\subsection{Wsparcie dla kolejek}

W~sekcji~\ref{sec:patterns_and_antipatterns} został przytoczony antywzorzec kolejki. Problem został opisany przez Alekseya Yeschenko na blogu firmy DataStax.~\cite{cassandra_queue_antipattern} Wynika on ze sposobu obsługi operacji usuwania przez silnik Apache Cassandra. Usuwanie nie jest realizowane natychmiast. Zamiast tego kasowana kolumna oznaczana jest specjalnym znacznikiem \emph{tombstone} i~rezyduje w~pamięci aż do momentu, gdy nastąpi właściwe wyrzucanie. Przy dużej liczbie usunięć kolumn z~wiersza może zdarzyć się, że zapytanie filtrujące z~limitem będzie działało znacznie wolniej niż dla wiersza z~identyczną ilością kolumn, ale bez poprzedzających usunięć. Wynika to z~faktu, że stwierdzenie, że dana wartość jest ,,martwa'' wymaga pobrania kolumny i~zdeserializowania jej wartości. Jeżeli po deserializacji wykryty zostanie znacznik \emph{tombstone}, wtedy pobierana jest kolejna wartość. Proces powtarzany jest aż do skutku.

Kolejka może być zamodelowana efektywniej w~przypadku, gdy możliwe jest wskazanie miejsca, w~którym rozpoczynają się nieusunięte kolumny. Przykładem może być kolejka typu FIFO\footnote{FIFO (First In, First Out) - rodzaj kolejki, w~którym elementy obsługiwane są według kolejności wstawienia.}. Wyszukując kolejny element w~kolejce można nałożyć warunek, że czas wstawienia elementu do kolejki jest późniejszy niż czas ostatnio usuniętego elementu. OMC dostarcza wsparcia dla takich kolejek, co zostało przedstawione na listingu~\ref{lst:fifo_queue_modeling}.

\begin{verbbox}
class FIFOQueue(Model):
    __track_deletes__ = ('enqueued_at', 'ASC')
    name = TextField(partitioning_key=True)
    enqueued_at = UuidField(type=TimeUuid, 
                            auto_generate=True, 
                            clustering_key=True)
    payload = DataField()

# create three queue elements

first_element = FIFOQueue(name = '1', payload = 'firstPayload')
second_element = FIFOQueue(name = '2', payload = 'secondPayload')
third_element = FIFOQueue(name = '3', payload = 'thirdPayload')

# save elements into database

first_element.save()
second_element.save()
third_element.save()

# delete first two elements from database

first_element.delete()
second_element.delete()

# get element with name '3'

FIFOQueue.objects().find(name='3')[:1]
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie kolejki typu FIFO w~OMC.}
	\label{lst:fifo_queue_modeling}
\end{figure}

Parametr \verb+__track_deletes__+ umożliwia śledzenie operacji usuwania. Przyjmuje on parę łańcuchów znaków: nazwę pola, którego wartość jest śledzona podczas usuwania oraz warunek zapisywania śledzonej wartości. Na chwilę obecną obsługiwane jest śledzenie pól typu \verb+UuidField+ oraz \verb+TimestampField+, a~także dwa warunki śledzenia: \verb+ASC+ oraz \verb+DESC+. Warunek \emph{ascending} oznacza, że śledzona wartość jest aktualizowana tylko w~przypadku, gdy jest mniejsza od usuwanej obecnie wartości. Warunek \emph{descending} działa odwrotnie - aktualizuje śledzoną wartość tylko w~przypadku, gdy jest większa od usuwanej obecnie.

Ustawienie parametru \verb+__track_deletes__+ powoduje, że śledzona wartość jest automatycznie dodawana do wszystkich zapytań wyszukujących obiekty. Oznacza to, że ostatnie wywołanie w~listingu~\ref{lst:fifo_queue_modeling} będzie miało ustawione trzy warunki filtrowania:

\begin{itemize}
	\item Nazwa elementu (\verb+name+) jest równa \verb+'3'+ - wynika z~\verb+find(name='3')+.
	\item Wybierz maksymalnie jeden element (\verb+LIMIT 1+) - wynika z~zakresu \verb+[:1]+.
	\item Czas dodania do kolejki (\verb+enqueued_at+) większy od \verb+second_element.enqueued_at+ - automatycznie dodawane przez OMC.
\end{itemize}

\subsection{Selektywna aktualizacja}

Apache Cassandra jest przystosowana do obsługi wielu równoległych źródeł danych. Ze względu na brak transakcyjności jednym ze sposobów na uniknięcie problemów synchronizacji jest zalecana przez Dave'a Gardnera selektywna aktualizacja.~\cite{cassandra_concepts_patterns_antipatterns} Edytując zawartość danego wiersza należy przesyłać do bazy danych wyłącznie wartości, które rzeczywiście uległy modyfikacji. Inaczej istnieje prawdopodobieństwo niecelowego nadpisania zmian wprowadzonych równolegle przez inne źródło danych. OMC domyślnie korzysta z~mechanizmu selektywnej aktualizacji, co przedstawiono na listingu~\ref{lst:selective_update_modeling}.

\begin{verbbox}
class SelectiveUpdate(Model):
    name = TextField(partitioning_key=True)
    description = TextField(length=1024)
    priority = IntegerField()

# find object with name 'su_test'
su_test = SelectiveUpdate.objects().find(name='su_test').get()

# update priority
su_test.priority = 1

# update object
su_test.save()
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład selektywnej aktualizacji.}
	\label{lst:selective_update_modeling}
\end{figure}

W~pierwszej kolejności metoda \verb+save()+ sprawdza, którą z~dwóch operacji, aktualizacji czy wstawienia obiektu, należy wykonać. Przy wykonywaniu aktualizacji do bazy danych przesyłana jest tylko wartość zmienionych pól, w~danym przykładzie tylko priorytetu. Jeżeli pomiędzy pobraniem obiektu, a~aktualizacją priorytetu i~zapisaniem obiektu w~bazie danych inny węzeł dokona zmiany opisu obiektu, opis ten nie zostanie ponownie nadpisany poprzednią wartością.

Mechanizm aktualizacji selektywnej można wyłączyć. Można dokonać tego wywołując metodę \verb+save()+ z~parametrem \verb+selective_update=False+. Alternatywnie selektywna aktualizacja może zostać wyłączona dla całego modelu poprzez zadeklarowanie pola \verb+__selective_update__ = False+.

\subsection{Indeks wartości unikalnych}

Aby umożliwić wyszukiwanie po wartościach kolumny, która nie należy do klucza głównego tabeli należy użyć indeksu drugiego rzędu (\emph{secondary index}). Według dokumentacji Apache Cassandry~\cite{cassandra_indexes} indeksy drugiego stopnia powinny być używane na kolumnach, które silnie grupują wiersze encji nadrzędnej. Wynika to z~wewnętrznej implementacji indeksów drugiego stopnia. Załóżmy, że w~systemie istnieje tabela przechowująca dane użytkowników, w~której zapisane są wiersze zaprezentowane na diagramie~\ref{tab:secondary_index_example_users_table}.

\begin{figure}[ht!]
	\centering

	\begin{tabular}{|l||c|c|c|c|}
		\hhline{|-||----|}
		 & \textbf{name} & \textbf{surname} & \textbf{email} & \textbf{city} \\
		\hhline{|~||====|}
		\textbf{jturek} & Jakub & Turek & J.Turek@stud.elka.pw.edu.pl & Warsaw \\
		\hhline{|=::====}
		 & \textbf{name} & \textbf{surname} & \textbf{email} & \textbf{city} \\
		\hhline{|~||====|}
		\textbf{manisero} & Michał & Aniserowicz & M.Aniserowicz@stud.elka.pw.edu.pl & Warsaw \\
		\hhline{|-||----|}
	\end{tabular} 

	\caption{Przykładowe wartości w~tabeli użytkownicy.}
	\label{tab:secondary_index_example_users_table}
\end{figure}

Przykładowy wygląd danych w~tabeli, która realizuje indeks drugiego stopnia dla miasta (kolumna \verb+city+), został zaprezentowany na diagramie~\ref{tab:secondary_index_example_index_table}.

\begin{figure}[ht!]
	\centering

	\begin{tabular}{|l||c|c|}
		\hhline{|-||--|}
		 & \textbf{jturek} & \textbf{manisero} \\
		\hhline{|~||==|}
		\textbf{Warsaw} & null & null \\
		\hhline{|-||--|}
	\end{tabular} 

	\caption{Przykładowa tabela, która mogłaby realizować indeks drugiego stopnia dla kolumny \emph{city} z~diagramu~\ref{tab:secondary_index_example_users_table}.}
	\label{tab:secondary_index_example_index_table}
\end{figure}

Wadą rozwiązania przedstawionego na diagramie~\ref{tab:secondary_index_example_index_table} jest brak skalowalności. Przy dodawaniu użytkowników wiersz rozszerza się o~kolejne kolumny, które przechowywane są na tym samym węźle. Zajmuje to dużo miejsca na jednej partycji. Dodatkowo wszystkie zapytania o~dany indeks zawsze odwołują się do jednego węzła, co skutkuje nierównomiernym rozłożeniem obciążenia. Ze względu na wymienione wady indeksy drugiego stopnia są realizowane lokalnie. Każdy węzeł zawiera informacje o~wszystkich indeksowanych kolumnach, ale wyłącznie o~kluczach wierszy, które znajdują się na danym węźle. Oznacza to, że jeżeli użytkownicy \textbf{jturek} oraz \textbf{manisero} znajdują się na różnych węzłach, również indeks jest równomiernie dystrybuowany pomiędzy te dwa węzły.

Lokalne indeksowanie wymusza odwołania do wszystkich węzłów dla każdego wyszukiwania. Zakładając, że indeksowanych wierszy (zarówno wszystkich, jak i~tych z~wyniku zapytania) jest dużo więcej niż węzłów, nadal znacząco przyspiesza to wyszukiwanie. Sytuacja zmienia się, gdy indeksowana jest wartość unikalna. Wtedy wbudowany w~Cassandrę mechanizm wymusza wykonanie wielu zapytań zamiast jednego. 

Indeks wartości unikalnych można zamodelować samodzielnie w~prosty sposób.~\cite{unique_column_index} Wystarczy utworzyć nową tabelę, w~której unikalna wartość jest identyfikatorem. W~wierszu dla danej unikalnej wartości zapisany jest odpowiedni identyfikator. Przykład takiego indeksu dla adresu e-mail (kolumna \verb+email+) użytkowników przedstawiono na diagramie~\ref{tab:custom_unique_value_index_table}.

\begin{figure}[ht!]
	\centering

	\begin{tabular}{ll}
		UserEmailIndex &
		\begin{tabular}{|l||c|}
			\hhline{|-||-|}
		 	& \textbf{jturek} \\
			\hhline{|~||=|}
			\textbf{J.Turek@stud.elka.pw.edu.pl} & null \\
			\hhline{|=::=}
			 & \textbf{manisero} \\
			\hhline{|~||=|}
			\textbf{M.Aniserowicz@stud.elka.pw.edu.pl} & null \\
			\hhline{|-||-|}
		\end{tabular} 
	\end{tabular}

	\caption{Przykład tabeli przechowującej indeks dla unikalnych wartości (adres e-mail użytkownika).}
	\label{tab:custom_unique_value_index_table}
\end{figure}

OMC wspiera automatyczne tworzenie indeksów dla wartości unikalnych. Na listingu~\ref{lst:omc_unique_index_modeling} przedstawiono sposób utworzenia indeksu dla wartości unikalnych dla pola \verb+email+.

\begin{verbbox}
class User(Model):
    id = UuidField(type=TimeUuid, auto_generate=True, partition_key=True)
    name = TextField()
    surname = TextField()
    email = TextField(searchable_unique=True)
    city = TextField(searchable=True)
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Modelowanie tabeli użytkownicy z~wykorzystaniem indeksu dla wartości unikalnych.}
	\label{lst:omc_unique_index_modeling}
\end{figure}

Flaga \verb+searchable_unique=True+ powoduje, że dla danego pola tworzony jest indeks unikalny. Indeks jest w~całości zarządzany przez OMC. Podczas wyszukiwania metodą \verb+User.objects().find(email='J.Turek@stud.elka.pw.edu.pl')+ mechanizm wyszukuje identyfikator użytkownika w~stworzonym przez siebie indeksie. OMC aktualizuje indeksy podczas wykonywania operacji \verb+save()+ oraz \verb+delete()+.

Zarówno indeks wartości unikatowych, jak również domyślny indeks drugiego stopnia (tworzony przy użyciu flagi \verb+searchable=True+) nazywane są przy użyciu tej samej konwencji. Pierwszą składową jest nazwa encji, drugą - nazwa pola, a~trzecia to słowo ,,index''. Dla przykładu \ref{lst:omc_unique_index_modeling} indeks wartości unikatowych zostanie umieszczony w~tabeli o~nazwie \verb+user_email_index+.

\section{Przetwarzanie partiami}

Apache Cassandra zapewnia wsparcie dla operacji atomowych.~\cite{cassandra_batch_operations} Wykorzystując partie\footnote{Partia (ang. batch) - zgrupowany zestaw zapytań INSERT, UPDATE lub DELETE.} można wykonać zestaw operacji, z~których (cytując dokumentację) ,,jeżeli jedna się powiedzie, to wykonają się wszystkie''. Nie jest to jednak odpowiednik transakcji znanych z~relacyjnych baz danych. Apache Cassandra nie zapewnia integralności wykonywanych w~partii zapytań: dane mogą być modyfikowane równolegle przez inne zapytania. Przykład atomowych operacji został zaprezentowany na diagramie~\ref{lst:batch_operation_cql_example}. Jest to zestaw dwóch zapytań, które usuwają z~bazy danych użytkownika i~właściwy mu indeks dla pola e-mail.

\begin{verbbox}
	BEGIN BATCH
	  DELETE FROM user WHERE userId = 'jturek'
	  DELETE FROM user_mail_index WHERE mail = 'J.Turek@stud.elka.pw.edu.pl'
	APPLY BATCH;
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład operacji na partii, która usuwa z~bazy danych użytkownika \emph{jturek} i~jego indeks dla pola email.}
	\label{lst:batch_operation_cql_example}
\end{figure}

Silnik wykorzystywany w~OCM zapewnia wsparcie dla przetwarzania partiami. Potrafi kolejkować wszystkie zapytania DML\footnote{Data Modification Language (ang. język modyfikacji danych) - podzbiór zapytań obejmujących wstawianie (INSERT), aktualizację (UPDATE) oraz usuwanie (DELETE) danych.}, a~następnie wykonywać zapytania z~kolejki jako operacja atomowa. Przykład wykorzystania operacji na partiach w~OCM zaprezentowano na listingu~\ref{lst:ocm_batch_support}.

\begin{verbbox}
	# starts batch
	Model.begin_batch()
	# create new Item
	item = Item(name='item', description='desc', price=12.5)
	item.save()    # save is queued
	wishlist = Wishlist(userId='jturek', itemId=item.id)
	wishlist.save()    # save is queued
	# executes item.save() and wishlist.save()
	Model.apply_batch()
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład wykonania operacji na partii, która wstawia do bazy nowy przedmiot i~dodaje go do listy życzeń użytkownika.}
	\label{lst:ocm_batch_support}
\end{figure}

Wywołanie metody \verb+Model.begin_batch()+ powoduje rozpoczęcie kolejkowania zapytań DML. Operacja wstawienia nowego przedmiotu (\verb+item.save()+) nie wykonuje się od razu, ale jest umieszczana w~kolejce. Do kolejki trafia również operacja aktualizacji listy życzeń użytkownika (\verb+wishlist.save()+). Wywołanie metody \verb+Model.apply_batch()+ powoduje, że partia dwóch zgrupowanych zapytań wykonuje się.

\section{Wsparcie dla liczników}

Apache Cassandra udostępnia wsparcie dla specjalnego typu danych - liczników.~\cite{cassandra_counters} Liczniki to kolumny specjalnego typu \verb+counter+, na których można wykonywać tylko dwie operacje: inkrementacja lub dekrementacja. Poza specjalnym typem zmienia się również sposób interakcji z~tabelą. Nie można wstawiać do niej wartości, a~jedynie aktualizować liczniki dla różnych kombinacji pozostałych pól. 

OMC wspiera modelowanie liczników. Przykład przedstawiono na listingu~\ref{lst:ocm_counter_support}.

\begin{verbbox}
class TripCounter(Model):
    country = TextField(partitioning_key=True)
    visits = CounterField()

sweden = TripCounter(country='Sweden')
sweden.visits.increment(1)
sweden.save()

poland = TripCounter(country='Poland')
poland.visits.increment(5)
poland.visits.decrement(2)
poland.save()

s_visits = TripCounter.find(country='Sweden').get().visits    # 1
p_visits = TripCounter.find(country='Poland').get().visits    # 3
\end{verbbox}

\begin{figure}[ht!]
	\centering
	\theverbbox
	\caption{Przykład użycia liczników w~OCM.}
	\label{lst:ocm_counter_support}
\end{figure}

Obsługa modelu posiadającego licznik różni się od wykorzystania standardowego modelu. Przede wszystkim wartości wszystkich pól są ustawione w~trybie \verb+read only+, czyli nie jest możliwe wykonanie operacji \verb+sweden.country = 'Germany'+. Dzięki temu wszystkie operacje wykonywane na liczniku są zawsze odpowiednio interpretowane, gdyż nie może się zmienić ich kontekst. W~przeciwnym razie trudno byłoby ocenić intencje programisty, który najpierw inkrementuje licznik o~2, a~następnie zmienia wartość kraju dla obiektu ze zwiększonym licznikiem. Mogło być to działanie celowe (operacje wykonane w~nieintuicyjnej kolejności) lub zwykły błąd. 

Pole typu \verb+CounterField+ udostępnia dwie operacje: inkrementację (\verb+increment()+) oraz dekrementację (\verb+decrement()+). Metody wywołane bez podania parametru standardowo zwiększają/zmniejszają wartość licznika o~1. Obie funkcje są łączne. Oznacza to, że tak jak w~przykładzie można dokonywać wielu operacji na jednym liczniku, które przed uaktualnieniem obiektu w~bazie danych są sumowane.

Po wykryciu pola licznikowego w~definicji modelu OCM automatycznie zmienia sposób obsługi obiektu. Nowo powstały obiekt jest traktowany tak, jakby został wcześniej pobrany z~bazy danych - operacja \verb+save()+ dokonuje aktualizacji, a~nie wstawienia. 